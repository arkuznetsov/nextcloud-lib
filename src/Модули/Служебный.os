// ----------------------------------------------------------
// This Source Code Form is subject to the terms of the
// Mozilla Public License, v.2.0. If a copy of the MPL
// was not distributed with this file, You can obtain one
// at http://mozilla.org/MPL/2.0/.
// ----------------------------------------------------------
// Codebase: https://github.com/ArKuznetsov/nextcloud-lib/
// ----------------------------------------------------------

#Использовать logos
#Использовать tempfiles
#Использовать strings
#Использовать 1connector

Перем Лог;

// Функция добавляет кавычки в начале и в конце переданной строки
//   
// Параметры:
//   Строка         - Строка        - Строка для добавления кавычек
//
// Возвращаемое значение:
//    Строка - строка с добавленными кавычками
//
Функция ОбернутьВКавычки(Знач Строка) Экспорт
	Если Лев(Строка, 1) = """" И Прав(Строка, 1) = """" Тогда
		Возврат Строка;
	Иначе
		Возврат СтрШаблон("""%1""", СтрЗаменить(Строка, """", """"""));
	КонецЕсли;
КонецФункции // ОбернутьВКавычки()

// Процедура - убирает в строке начальные и конечные кавычки
//
// Параметры:
//	Значение    - Строка     - строка для обработки
//
// Возвращаемое значение:
//    Строка     - строка без кавычек
//
Процедура УбратьКавычки(Значение) Экспорт

	Если Лев(Значение, 1) = """"  И Прав(Значение, 1) = """" Тогда
		Значение = Сред(Значение, 2, СтрДлина(Значение) - 2);
	КонецЕсли;

КонецПроцедуры // УбратьКавычки()

// Функция проверяет, что переданное значение является числом или строковым представлением числа
//   
// Параметры:
//   Параметр      - Строка, Число     - значение для проверки
//
// Возвращаемое значение:
//    Булево       - Истина - значение является числом или строковым представлением числа
//
Функция ЭтоЧисло(Параметр) Экспорт

	Если ТипЗнч(Параметр) = Тип("Число") Тогда
		Возврат Истина;
	КонецЕсли;

	Попытка
		ПараметрЧислом = Число(Параметр); //@skip-warning
	Исключение
		Возврат Ложь;
	КонецПопытки;

	Возврат Истина;

КонецФункции // ЭтоЧисло()

// Функция проверяет, что переданное значение является числом или строковым представлением числа
//   
// Параметры:
//   Параметр      - Строка, Число     - значение для проверки
//
// Возвращаемое значение:
//    Булево       - Истина - значение является числом или строковым представлением числа
//
Функция ЭтоGUID(Параметр) Экспорт

	РВ = Новый РегулярноеВыражение("(?i)[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}");
	
	Возврат РВ.Совпадает(Параметр);

КонецФункции // ЭтоGUID()

// Функция - возвращает Истина если значение является пустым GUID
//
// Параметры:
//    Значение      - Строка     - проверяемое значение
//
// Возвращаемое значение:
//    Булево     - Истина - значение является пустым GUID
//
Функция ЭтоПустойGUID(Значение) Экспорт

	Возврат (Значение = "00000000-0000-0000-0000-000000000000") ИЛИ НЕ ЗначениеЗаполнено(Значение);

КонецФункции // ЭтоПустойGUID()

// Функция - возвращает значение указанного поля структуры/соответствия или значение по умолчанию
//
// Параметры:
//   ПарамСтруктура      - Структура, Соответствие    - коллекция из которой возвращается значение
//   Ключ                - Произвольный               - значение ключа коллекции для получения значения
//   ПоУмолчанию         - Произвольный               - значение, возвращаемое в случае,
//                                                      когда ключ отсутствует в коллекции
//
// Возвращаемое значение:
//    Произвольный - значение элемента коллекции или значение по умолчанию
//
Функция ПолучитьЗначениеИзСтруктуры(ПарамСтруктура, Ключ, ПоУмолчанию = Неопределено) Экспорт

	Если ТипЗнч(ПарамСтруктура) = Тип("Структура") Тогда
		Если ПарамСтруктура.Свойство(Ключ) Тогда
			Возврат ПарамСтруктура[Ключ];
		КонецЕсли;
	ИначеЕсли ТипЗнч(ПарамСтруктура) = Тип("Соответствие") Тогда
		Если НЕ ПарамСтруктура.Получить(Ключ) = Неопределено Тогда
			Возврат ПарамСтруктура.Получить(Ключ);
		КонецЕсли;
	Иначе
		Возврат ПоУмолчанию;
	КонецЕсли;

КонецФункции // ПолучитьЗначениеИзСтруктуры()

// Функция - преобразует путь вида "tag1.tag2.[0].tag3" в массив
//
// Параметры:
//   ПутьКЭлементу    - Строка,       - путь к элементу структуры данных вида "tag1.tag2.[0].tag3"
//                      Произвольный
//
// Возвращаемое значение:
//    Массив Из (Строка, Число),    - если передана строка, то массив частей пути,
//    Произвольный                    переданное значение в противном случае
//
Функция ПутьКЭлементуВМассив(Знач ПутьКЭлементу = "") Экспорт

	Если НЕ ТипЗнч(ПутьКЭлементу) = Тип("Строка") Тогда
		Возврат ПутьКЭлементу;
	КонецЕсли;

	ПутьКЭлементу = СтрРазделить(ПутьКЭлементу, ".");
	РВ = Новый РегулярноеВыражение("\[\d+\]");
	Для й = 0 По ПутьКЭлементу.ВГраница() Цикл
		// Если часть пути соответствует шаблону "[Число]", то это индекс в массиве
		// сохраняем как "Число"
		Если РВ.Совпадает(ПутьКЭлементу[й]) Тогда
			ПутьКЭлементу[й] = Число(Сред(ПутьКЭлементу[й], 2, СтрДлина(ПутьКЭлементу[й]) - 2));
		Иначе
			ПутьКЭлементу[й] = СокрЛП(ПутьКЭлементу[й]);
		КонецЕсли;
	КонецЦикла;

	Возврат ПутьКЭлементу;

КонецФункции // ПутьКЭлементуВМассив()

// Функция - проверяет доступность существование элемента данных соответствия или массива
//
// Параметры:
//   Данные       - Структура    - данные, для которых проверяется наличие элемента
//                  Массив
//   ЧастьПути    - Строка       - проверяемое имя элемента или индекс массива
//                  Число
//
// Возвращаемое значение:
//    Булево    - Истина - часть пути существует
//
Функция ЧастьПутиСуществует(Данные, ЧастьПути)

	Возврат (ТипЗнч(Данные) = Тип("Соответствие") И ЕстьЭлементСоответствия(Данные, ЧастьПути))
	    ИЛИ (ТипЗнч(Данные) = Тип("Массив") И ТипЗнч(ЧастьПути) = Тип("Число") И Данные.ВГраница() >= ЧастьПути);

КонецФункции // ЧастьПутиСуществует()

// Функция - получает значение элемента структуры данных по переданному пути
//
// Параметры:
//   Данные            - Структура           - данные, для которых получается значение элемента
//                       Массив
//   ПутьКЭлементу     - Массив из Строка    - массив - последовательность свойств/индексов
//                       Строка                или строка пути вида "tag1.tag2.[0].tag3"
//   Смещение          - Число               - отрицательное число - смещение от конца пути к элементу
//   ВыдаватьОшибку    - Число               - Истина - в случае невозможности получения элемента
//                                             будет выброшено исключение
//
// Возвращаемое значение:
//    Булево    - Истина - часть пути существует
//
Функция ЗначениеЭлементаСтруктуры(Знач Данные,
	                              Знач ПутьКЭлементу = "",
	                              Знач Смещение = 0,
	                              Знач ВыдаватьОшибку = Ложь) Экспорт

	ПутьКЭлементу = ПутьКЭлементуВМассив(ПутьКЭлементу);

	Результат = Данные;

	ТекущийПуть = "";

	// Обрабатываем элементов не больше чем "Количество элементов пути - Смещение"
	ГлубинаСвойств = Мин(ПутьКЭлементу.ВГраница(), ПутьКЭлементу.ВГраница() + Смещение);

	Для й = 0 По ГлубинаСвойств Цикл
		
		ЧастьПути = ПутьКЭлементу[й];
		Если ТипЗнч(ЧастьПути) = Тип("Число") Тогда
			ЧастьПути = СтрШаблон("[%1]", ЧастьПути);
		КонецЕсли;

		Если ЧастьПутиСуществует(Результат, ПутьКЭлементу[й]) Тогда
			Результат = Результат[ПутьКЭлементу[й]];
		ИначеЕсли ВыдаватьОшибку Тогда
			ВызватьИсключение СтрШаблон("Отсутствует свойство %1.(?)%2", ТекущийПуть, ЧастьПути);
		Иначе
			Лог.Предупреждение("Отсутствует свойство %1.(?)%2", ТекущийПуть, ЧастьПути);
			Возврат Неопределено;
		КонецЕсли;
		ТекущийПуть = ?(ТекущийПуть = "",
		                ЧастьПути,
		                СтрШаблон("%1.%2", ТекущийПуть, ЧастьПути));
	КонецЦикла;

	Возврат Результат;

КонецФункции // ЗначениеЭлементаСтруктуры()

// Процедура - добавляет элемент данных в структуру данных
//
// Параметры:
//   ЭлементРодитель    - Структура           - структура данных, куда будет добавлен элемент
//                        Массив
//   ПутьКЭлементу     - Массив из Строка    - (возвр.) массив - последовательность свойств/индексов
//   ИмяЭлемента       - Строка              - имя добавляемого элемента
//
Процедура ДобавитьЭлементДанных(ЭлементРодитель, ПутьКЭлементу, ИмяЭлемента)

	Если ТипЗнч(ЭлементРодитель) = Тип("Соответствие") Тогда
		Если ЕстьЭлементСоответствия(ЭлементРодитель, ИмяЭлемента) Тогда
			Если ТипЗнч(ЭлементРодитель[ИмяЭлемента]) = Тип("Строка")
			 ИЛИ ТипЗнч(ЭлементРодитель[ИмяЭлемента]) = Тип("Соответствие") Тогда
				Значение = ЭлементРодитель[ИмяЭлемента];
				ЭлементРодитель.Вставить(ИмяЭлемента, Новый Массив());
				ЭлементРодитель[ИмяЭлемента].Добавить(Значение);
			КонецЕсли;
			ЭлементРодитель[ИмяЭлемента].Добавить(Новый Соответствие());
			ПутьКЭлементу.Добавить(ИмяЭлемента);
			ПутьКЭлементу.Добавить(ЭлементРодитель[ИмяЭлемента].ВГраница());
		Иначе
			ЭлементРодитель.Вставить(ИмяЭлемента, Новый Соответствие());
			ПутьКЭлементу.Добавить(ИмяЭлемента);
		КонецЕсли;
	КонецЕсли;

КонецПроцедуры // ДобавитьЭлементДанных()

// Функция - читает XML-строку и преобразует в структуру данных (Соответствие)
//
// Параметры:
//   ТекстXML    - Строка    - XML-строку для преобразования
//
// Возвращаемое значение:
//    Соответствие    - прочитанная структура данных
//
Функция ПрочитатьXMLВСтруктуру(ТекстXML) Экспорт

	Парсер = Новый ЧтениеXML;
	Парсер.УстановитьСтроку(ТекстXML);
 
	Результат = Новый Соответствие();

	ПутьКЭлементу = Новый Массив();
 
	Пока Парсер.Прочитать() Цикл

		ТекЭлемент = ЗначениеЭлементаСтруктуры(Результат, ПутьКЭлементу);

		Если Парсер.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда

			ДобавитьЭлементДанных(ТекЭлемент, ПутьКЭлементу, Парсер.Имя);

		ИначеЕсли Парсер.ТипУзла = ТипУзлаXML.Текст Тогда

			Если ТипЗнч(ТекЭлемент) = Тип("Массив") Тогда
				ТекЭлемент.Добавить(Парсер.Значение);
			Иначе
				Контейнер = ЗначениеЭлементаСтруктуры(Результат, ПутьКЭлементу, -1);
				Контейнер[ПутьКЭлементу[ПутьКЭлементу.ВГраница()]] = Парсер.Значение;
			КонецЕсли;

		ИначеЕсли Парсер.ТипУзла = ТипУзлаXML.КонецЭлемента Тогда

			Если ТипЗнч(ТекЭлемент) = Тип("Соответствие") И ТекЭлемент.Количество() = 0 Тогда
				Контейнер = ЗначениеЭлементаСтруктуры(Результат, ПутьКЭлементу, -1);
				Контейнер[ПутьКЭлементу[ПутьКЭлементу.ВГраница()]] = Неопределено;
			КонецЕсли;
			
			Если ТипЗнч(ПутьКЭлементу[ПутьКЭлементу.ВГраница()]) = Тип("Число") Тогда
				ПутьКЭлементу.Удалить(ПутьКЭлементу.ВГраница());
			КонецЕсли;
			ПутьКЭлементу.Удалить(ПутьКЭлементу.ВГраница());

		КонецЕсли;

	КонецЦикла;
 
    Парсер.Закрыть();

	Возврат Результат;

КонецФункции // ПрочитатьXMLВСтруктуру()

// Функция - проверяет наличие в соответствии элемента с указанным ключом (регистронезависимо)
//
// Параметры:
//   Соответствие    - Соответствие    - проверяемое соответствие
//   Ключ            - Строка          - проверяемый ключ
//
// Возвращаемое значение:
//    Булево    - Истина - элемент с указанным ключ присутствует в соответствии
//
Функция ЕстьЭлементСоответствия(Соответствие, Ключ = Неопределено) Экспорт

	Для Каждого ТекЭлемент Из Соответствие Цикл
		Если НРег(ТекЭлемент.Ключ) = НРег(Ключ) Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;

	Возврат Ложь;

КонецФункции // ЕстьЭлементСоответствия()

// Функция возвращает лог библиотеки
//
// Возвращаемое значение:
//    Логгер - лог библиотеки
//
Функция Лог() Экспорт
	
	Если Лог = Неопределено Тогда
		Лог = Логирование.ПолучитьЛог(ИмяЛога());
	КонецЕсли;

	Возврат Лог;

КонецФункции // Лог()

// Функция возвращает имя лога библиотеки
//   
// Возвращаемое значение:
//    Строка - имя лога библиотеки
//
Функция ИмяЛога() Экспорт

	Возврат "oscript.lib.nextcloud";
	
КонецФункции // ИмяЛога()
